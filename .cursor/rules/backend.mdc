---
description: Backend rules for NestJS development - triggered when working on backend files
globs:
  - "backend/**/*"
  - "api/**/*"
  - "**/modules/**/*"
  - "**/dto/**/*"
  - "**/entities/**/*"
  - "**/*.controller.ts"
  - "**/*.service.ts"
  - "**/*.module.ts"
alwaysApply: false
---

# Backend Development Rules (NestJS + Supabase)

## Module Structure
Every feature module follows this structure:
```
src/modules/[feature]/
├── dto/
│   ├── create-[feature].dto.ts
│   ├── update-[feature].dto.ts
│   └── query-[feature].dto.ts
├── entities/
│   └── [feature].entity.ts
├── [feature].controller.ts
├── [feature].service.ts
├── [feature].module.ts
└── [feature].spec.ts
```

## Controller Rules
- Use `@Controller('[feature]')` decorator
- Apply `@UseGuards(JwtAuthGuard)` to all routes (unless public)
- Use proper HTTP decorators: `@Get()`, `@Post()`, `@Put()`, `@Delete()`
- Use `@Body()`, `@Param()`, `@Query()` for input
- Use `@CurrentUser()` decorator for authenticated user
- Return consistent response format: `{ data, meta?, error? }`
- Add Swagger decorators for API documentation

## Service Rules
- All business logic lives in services, NOT controllers
- Inject Supabase client via `@InjectSupabaseClient()`
- Handle Supabase errors and throw proper NestJS exceptions
- Use transactions for multi-table operations
- Return typed data, not raw Supabase responses

## DTO Validation
- Use class-validator decorators on ALL properties
- Use class-transformer for data transformation
- Required fields: no decorator needed (default)
- Optional fields: use `@IsOptional()`
- Always trim strings: `@Transform(({ value }) => value?.trim())`
- Validate nested objects with `@ValidateNested()` and `@Type()`

## Common DTO Patterns
```typescript
// Pagination
@IsOptional() @IsInt() @Min(1) page?: number = 1;
@IsOptional() @IsInt() @Min(1) @Max(100) limit?: number = 20;

// Search/Filter
@IsOptional() @IsString() search?: string;
@IsOptional() @IsEnum(Status) status?: Status;

// UUID params
@IsUUID() id: string;
```

## Error Handling
- Use NestJS built-in exceptions: BadRequestException, NotFoundException, UnauthorizedException, ForbiddenException
- Create custom exceptions for domain-specific errors
- Never expose internal errors to client - log them, return generic message
- Always validate ownership before update/delete (prevent IDOR)

## Supabase Integration
- Use service role key in backend (full access)
- Implement RLS policies as additional security layer
- Handle Supabase errors explicitly
- Use parameterized queries (Supabase handles this)
- Log all database errors for debugging

## Security Checklist
- [ ] JWT guard on all non-public endpoints
- [ ] Role/permission guards where needed
- [ ] Input validation on all DTOs
- [ ] Ownership verification for user-specific data
- [ ] Rate limiting on sensitive endpoints
- [ ] No sensitive data in responses (passwords, tokens)
- [ ] Audit logging for important actions

## API Response Format
```typescript
// Success
{ data: T, meta?: { total, page, limit } }

// Error
{ error: { code: string, message: string } }
```
## Pagination & Search - MANDATORY for GET List Endpoints

Every GET endpoint returning a list MUST support:

### Required Query Parameters
- `page` (number, default: 1)
- `limit` (number, default: 20, max: 100)
- `search` (string, optional) - searches relevant text fields
- `sortBy` (string, optional) - field name
- `sortOrder` ('asc' | 'desc', default: 'desc')

### Required Response Format
```json
{
  "data": [...],
  "meta": {
    "total": 150,
    "page": 1,
    "limit": 20,
    "totalPages": 8
  }
}
```

### Standard Query DTO
Every list endpoint uses pagination DTO:
- Extend from `BasePaginationDto`
- Add feature-specific filters

### Search Implementation
In GET APIs ensure, there is search related query so we can search the data we fetched.



## Naming Conventions
- Controllers: PascalCase + Controller suffix
- Services: PascalCase + Service suffix
- DTOs: Create/Update/Query + Feature + Dto
- Entities: PascalCase (singular)
- Files: kebab-case


